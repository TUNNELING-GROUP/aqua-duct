

<!doctype html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>aquaduct.geom.master &#8212; Aqua-Duct 0.3.1 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/bizstyle.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.3.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../../_static/bizstyle.js"></script>
    <link rel="shortcut icon" href="../../../_static/ficon.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <!--[if lt IE 9]>
    <script type="text/javascript" src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Aqua-Duct 0.3.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../aquaduct.html" accesskey="U">aquaduct</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/AQUADUCT_LOGO.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for aquaduct.geom.master</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>

<span class="c1"># Aqua-Duct, a tool facilitating analysis of the flow of solvent molecules in molecular dynamic simulations</span>
<span class="c1"># Copyright (C) 2016-2017  Tomasz Magdziarz, Alicja Płuciennik, Michał Stolarczyk &lt;info@aquaduct.pl&gt;</span>
<span class="c1">#</span>
<span class="c1"># This program is free software: you can redistribute it and/or modify</span>
<span class="c1"># it under the terms of the GNU General Public License as published by</span>
<span class="c1"># the Free Software Foundation, either version 3 of the License, or</span>
<span class="c1"># (at your option) any later version.</span>
<span class="c1">#</span>
<span class="c1"># This program is distributed in the hope that it will be useful,</span>
<span class="c1"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1"># GNU General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU General Public License</span>
<span class="c1"># along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>

<span class="c1"># this modlue is a prototype and have to be rewritten</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">multiprocessing</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="k">import</span> <span class="n">Queue</span><span class="p">,</span> <span class="n">Manager</span><span class="p">,</span> <span class="n">Lock</span><span class="p">,</span> <span class="n">Value</span><span class="p">,</span> <span class="n">Process</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">izip_longest</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="k">import</span> <span class="n">partial</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="k">import</span> <span class="n">cdist</span><span class="p">,</span> <span class="n">pdist</span>

<span class="kn">from</span> <span class="nn">aquaduct.traj.paths</span> <span class="k">import</span> <span class="n">GenericPathTypeCodes</span><span class="p">,</span> <span class="n">GenericPaths</span><span class="p">,</span> <span class="n">yield_single_paths</span><span class="p">,</span> <span class="n">MasterPath</span>
<span class="kn">from</span> <span class="nn">aquaduct.utils.helpers</span> <span class="k">import</span> <span class="n">list_blocks_to_slices</span><span class="p">,</span> <span class="n">strech_zip</span><span class="p">,</span> <span class="n">zip_zip</span><span class="p">,</span> <span class="n">xzip_xzip</span><span class="p">,</span> <span class="n">concatenate</span>
<span class="kn">from</span> <span class="nn">aquaduct.utils</span> <span class="k">import</span> <span class="n">clui</span>
<span class="kn">from</span> <span class="nn">aquaduct.utils.maths</span> <span class="k">import</span> <span class="n">make_default_array</span><span class="p">,</span> <span class="n">defaults</span>
<span class="kn">from</span> <span class="nn">aquaduct.traj.inlets</span> <span class="k">import</span> <span class="n">InletClusterGenericType</span><span class="p">,</span> <span class="n">InletClusterExtendedType</span>

<span class="c1">################################################################################</span>
<span class="n">part2type_dict</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="n">GenericPathTypeCodes</span><span class="o">.</span><span class="n">scope_name</span><span class="p">,</span>
                  <span class="mi">1</span><span class="p">:</span> <span class="n">GenericPathTypeCodes</span><span class="o">.</span><span class="n">object_name</span><span class="p">,</span>
                  <span class="mi">2</span><span class="p">:</span> <span class="n">GenericPathTypeCodes</span><span class="o">.</span><span class="n">scope_name</span><span class="p">}</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Part number to :class:`~aquaduct.traj.paths.GenericPathTypeCodes` dictionary.</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="n">parts</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Parts enumerate.</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="c1">################################################################################</span>


<div class="viewcode-block" id="CTypeSpathsCollectionWorker"><a class="viewcode-back" href="../../../aquaduct.geom.master.html#aquaduct.geom.master.CTypeSpathsCollectionWorker">[docs]</a><span class="k">class</span> <span class="nc">CTypeSpathsCollectionWorker</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Worker class for averaging spaths in points of master path.</span>
<span class="sd">    &#39;&#39;&#39;</span>
<div class="viewcode-block" id="CTypeSpathsCollectionWorker.__init__"><a class="viewcode-back" href="../../../aquaduct.geom.master.html#aquaduct.geom.master.CTypeSpathsCollectionWorker.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spaths</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ctype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bias_long</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">smooth</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Core method for averaging spaths in to master path.</span>

<span class="sd">        Averaging is done in chunks.</span>

<span class="sd">        :param list spaths: List of separate paths to average.</span>
<span class="sd">        :param InletClusterGenericType ctype: CType of spaths.</span>
<span class="sd">        :param int bias_long: Bias towards long paths used in :meth:`lens_norm`.</span>
<span class="sd">        :param Smooth smooth: Smoothing method.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">spaths</span> <span class="o">=</span> <span class="n">spaths</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ctype</span><span class="p">,</span> <span class="n">InletClusterGenericType</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ctype</span><span class="p">,</span> <span class="n">InletClusterExtendedType</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctype</span> <span class="o">=</span> <span class="n">ctype</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bias_long</span> <span class="o">=</span> <span class="n">bias_long</span> <span class="c1"># TODO: check if it is required here</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">smooth</span> <span class="o">=</span> <span class="n">smooth</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">lens_cache</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lens_real_cache</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lens_norm_cache</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">full_size_cache</span> <span class="o">=</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="CTypeSpathsCollectionWorker.coords_types_prob_widths"><a class="viewcode-back" href="../../../aquaduct.geom.master.html#aquaduct.geom.master.CTypeSpathsCollectionWorker.coords_types_prob_widths">[docs]</a>    <span class="k">def</span> <span class="nf">coords_types_prob_widths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sp_slices_</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Calculates average coordinates, type and width in given chunk.</span>

<span class="sd">        Parameter :attr:`sp_slices_` is tuple of length equal to number of spaths. It contains slices for all spaths respectively. With these slices spaths are cut and **only** resulting chunks are used for calculations.</span>

<span class="sd">        Therefore, this method average spaths in one point of master math. This point is defined by slices submitted as :attr:`sp_lices_` parameter.</span>

<span class="sd">        Algorithm of averaging (within current chunks of spaths):</span>

<span class="sd">        #. Coordinates for all spaths are collected.</span>
<span class="sd">        #. Lengths of all spaths are collected (from cached variables) and kept as lists of lengths equal to chunks&#39; sizes.</span>

<span class="sd">            .. note::</span>

<span class="sd">                Lengths of collected lengths of spaths are of the same size as coordinates</span>

<span class="sd">        #. New coordinates are calculated as weighted average of collected coordintates with :func:`numpy.average`. As weights collected lengths are used.</span>

<span class="sd">            .. note::</span>

<span class="sd">                Function :func:`numpy.average` is called with flatten coordinates and lengths.</span>

<span class="sd">        #. Width of average path is calculated as mean value of flatten coordinates mutual distances.</span>
<span class="sd">        #. Type of average paths is calculated as probability (frequency) of :attr:`~aquaduct.traj.paths.GenericPathTypeCodes.scope_name`.</span>

<span class="sd">        :param tuple sp_slices_: Slices that cut chunks from all paths.</span>
<span class="sd">        :rtype: 3 element tuple</span>
<span class="sd">        :return: coordinates, type (frequency), and width of averaged spaths in current point</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="c1"># get zz coords, zz means zip_zip - for all spaths</span>
        <span class="n">coords_zz</span> <span class="o">=</span> <span class="p">[</span><span class="n">sp</span><span class="o">.</span><span class="n">get_coords_cont</span><span class="p">(</span><span class="n">smooth</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">smooth</span><span class="p">)[</span><span class="n">sl</span><span class="p">]</span> <span class="k">for</span> <span class="n">sp</span><span class="p">,</span> <span class="n">sl</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spaths</span><span class="p">,</span> <span class="n">sp_slices_</span><span class="p">)]</span>

        <span class="c1"># make lens_zz which are lens corrected to the lenghts of coords_zz and normalized to zip_zip number of obejcts</span>
        <span class="n">lens_zz</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">coord_z</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lens_cache</span><span class="p">,</span> <span class="n">coords_zz</span><span class="p">):</span>
            <span class="c1"># l is lenght for one spath</span>
            <span class="c1"># coord_z are coordinates of this path (sliced to current chunk)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coord_z</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">lens_zz</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">coord_z</span><span class="p">)]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">coord_z</span><span class="p">))</span>  <span class="c1"># normalize and correct lengths</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># lens_zz.append([float(l)] * len(coord_z))</span>
                <span class="n">lens_zz</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>

        <span class="c1"># here we have coords_zz, lens_zz</span>
        <span class="c1"># and we can calculate coords, types_prob, widths</span>

        <span class="c1"># concatenate zip_zip coords and lens</span>
        <span class="n">coords_zz_cat</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">concatenate</span><span class="p">(</span><span class="o">*</span><span class="n">coords_zz</span><span class="p">))</span>
        <span class="k">del</span> <span class="n">coords_zz</span>

        <span class="n">lens_zz_cat</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">concatenate</span><span class="p">(</span><span class="o">*</span><span class="n">lens_zz</span><span class="p">))</span>
        <span class="k">del</span> <span class="n">lens_zz</span>
        <span class="c1"># average coords_zz_cat using weights of lens_zz_cat</span>

        <span class="n">coords_to_append</span> <span class="o">=</span> <span class="n">make_default_array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">coords_zz_cat</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">lens_zz_cat</span><span class="p">))</span>
        <span class="k">del</span> <span class="n">lens_zz_cat</span>

        <span class="c1"># calculate widths</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spaths</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># is the len of coords_zz the same as sp_slices_ and self.spaths?</span>
            <span class="n">widths_to_append</span> <span class="o">=</span> <span class="n">make_default_array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">pdist</span><span class="p">(</span><span class="n">coords_zz_cat</span><span class="p">,</span> <span class="s1">&#39;euclidean&#39;</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">widths_to_append</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="k">del</span> <span class="n">coords_zz_cat</span>

        <span class="c1"># concatenate zip_zip gtypes</span>
        <span class="n">types_zz_cat</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">concatenate</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">sp</span><span class="o">.</span><span class="n">gtypes_cont</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span> <span class="k">for</span> <span class="n">sp</span><span class="p">,</span> <span class="n">sl</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spaths</span><span class="p">,</span> <span class="n">sp_slices_</span><span class="p">)]))</span>
        <span class="k">del</span> <span class="n">sp_slices_</span>
        <span class="c1"># append type porbability to types</span>

        <span class="n">types_to_append</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">types_zz_cat</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">GenericPathTypeCodes</span><span class="o">.</span><span class="n">scope_name</span><span class="p">))</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">types_zz_cat</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">coords_to_append</span><span class="p">,</span> <span class="n">types_to_append</span><span class="p">,</span> <span class="n">widths_to_append</span></div>

<div class="viewcode-block" id="CTypeSpathsCollectionWorker.__call__"><a class="viewcode-back" href="../../../aquaduct.geom.master.html#aquaduct.geom.master.CTypeSpathsCollectionWorker.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nr_sp_slices_</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Callable interface.</span>

<span class="sd">        :param tuple nr_sp_slices_: Two element tuple: nr and sp_slice</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">nr_sp_slices_</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords_types_prob_widths</span><span class="p">(</span><span class="n">nr_sp_slices_</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span></div></div>


<div class="viewcode-block" id="CTypeSpathsCollection"><a class="viewcode-back" href="../../../aquaduct.geom.master.html#aquaduct.geom.master.CTypeSpathsCollection">[docs]</a><span class="k">class</span> <span class="nc">CTypeSpathsCollection</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Object for grouping separate paths that belong to the same CType.</span>
<span class="sd">    Method :meth:`get_master_path` allows for calculation of average path.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">parts</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># spath parts</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Enumeration of spath parts.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c1"># takes group of paths belonging to one ctype and allows to get MasterPath</span>
<div class="viewcode-block" id="CTypeSpathsCollection.__init__"><a class="viewcode-back" href="../../../aquaduct.geom.master.html#aquaduct.geom.master.CTypeSpathsCollection.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spaths</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ctype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bias_long</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">pbar</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">threads</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :param list spaths: List of separate paths.</span>
<span class="sd">        :param InletClusterGenericType ctype: CType of spaths.</span>
<span class="sd">        :param int bias_long: Bias towards long paths used in :meth:`lens_norm`.</span>
<span class="sd">        :param pbar: Progress bar object.</span>
<span class="sd">        :param int threads: Number of available threads.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pbar</span> <span class="o">=</span> <span class="n">pbar</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">threads</span> <span class="o">=</span> <span class="n">threads</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Threads passed </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">threads</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">spaths</span> <span class="o">=</span> <span class="n">spaths</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ctype</span><span class="p">,</span> <span class="n">InletClusterGenericType</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ctype</span><span class="p">,</span> <span class="n">InletClusterExtendedType</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctype</span> <span class="o">=</span> <span class="n">ctype</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bias_long</span> <span class="o">=</span> <span class="n">bias_long</span>

        <span class="c1"># precompute some values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beat</span><span class="p">()</span>

        <span class="k">with</span> <span class="n">clui</span><span class="o">.</span><span class="n">tictoc</span><span class="p">(</span><span class="s1">&#39;spaths props cache in </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctype</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lens_cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lens</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lens_real_cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lens_real</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lens_norm_cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lens_norm</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">full_size_cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_size</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beat</span><span class="p">()</span></div>

        <span class="c1"># self.lock = Lock()</span>

<div class="viewcode-block" id="CTypeSpathsCollection.beat"><a class="viewcode-back" href="../../../aquaduct.geom.master.html#aquaduct.geom.master.CTypeSpathsCollection.beat">[docs]</a>    <span class="k">def</span> <span class="nf">beat</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Touch progress bar, if any.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pbar</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pbar</span><span class="o">.</span><span class="n">heartbeat</span><span class="p">()</span></div>

<div class="viewcode-block" id="CTypeSpathsCollection.update"><a class="viewcode-back" href="../../../aquaduct.geom.master.html#aquaduct.geom.master.CTypeSpathsCollection.update">[docs]</a>    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Update progres bar by one, if any.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pbar</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="CTypeSpathsCollection.lens"><a class="viewcode-back" href="../../../aquaduct.geom.master.html#aquaduct.geom.master.CTypeSpathsCollection.lens">[docs]</a>    <span class="k">def</span> <span class="nf">lens</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns total lengths of all paths.</span>

<span class="sd">        If ctype in #:# and not 0 and not None then take length of `object` part only.</span>

<span class="sd">        :return: Total (or `object` part) lengths of all paths.</span>
<span class="sd">        :rtype: numpy.ndarray</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctype</span><span class="o">.</span><span class="n">input</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctype</span><span class="o">.</span><span class="n">input</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctype</span><span class="o">.</span><span class="n">input</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctype</span><span class="o">.</span><span class="n">output</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">make_default_array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">types_object</span><span class="p">))</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spaths</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">make_default_array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spaths</span><span class="p">])</span></div>

<div class="viewcode-block" id="CTypeSpathsCollection.lens_norm"><a class="viewcode-back" href="../../../aquaduct.geom.master.html#aquaduct.geom.master.CTypeSpathsCollection.lens_norm">[docs]</a>    <span class="k">def</span> <span class="nf">lens_norm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns normalized lengths calculated by :meth:`lens`.</span>

<span class="sd">        Applied normalization is twofold:</span>

<span class="sd">        #. All lengths are divided by maximal length, and</span>
<span class="sd">        #. All lengths are subjected to :func:`pow` function with p = :attr:`bias_long`.</span>

<span class="sd">        :return: Normalized total (or `object` part) lengths of all paths.</span>
<span class="sd">        :rtype: numpy.ndarray</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">lens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lens</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">lens</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">lens</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">lens</span><span class="p">)</span>  <span class="c1"># normalize</span>
            <span class="k">return</span> <span class="n">lens</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">bias_long</span>  <span class="c1"># bias to long paths</span></div>

<div class="viewcode-block" id="CTypeSpathsCollection.lens_real"><a class="viewcode-back" href="../../../aquaduct.geom.master.html#aquaduct.geom.master.CTypeSpathsCollection.lens_real">[docs]</a>    <span class="k">def</span> <span class="nf">lens_real</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns real lengths of all paths.</span>

<span class="sd">        :return: Sizes of all paths.</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">sp</span><span class="o">.</span><span class="n">size</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spaths</span><span class="p">]</span></div>

<div class="viewcode-block" id="CTypeSpathsCollection.full_size"><a class="viewcode-back" href="../../../aquaduct.geom.master.html#aquaduct.geom.master.CTypeSpathsCollection.full_size">[docs]</a>    <span class="k">def</span> <span class="nf">full_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns desired size of master path.</span>

<span class="sd">        :return: Size of master path.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># first check what is the size of paths in all parts and normalize and then scale them</span>
        <span class="n">sizes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parts</span><span class="p">:</span>
            <span class="c1"># lengths of all paths of part part</span>
            <span class="n">lens</span> <span class="o">=</span> <span class="n">make_default_array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">types</span><span class="p">[</span><span class="n">part</span><span class="p">]))</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spaths</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">lens</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">lens</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">lens</span><span class="p">)</span>  <span class="c1"># normalization</span>
                <span class="n">lens</span> <span class="o">=</span> <span class="n">lens</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">bias_long</span>  <span class="c1"># scale them by increasing weights of long paths</span>
            <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">lens</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># weighted average by paths lengths</span>
                <span class="n">sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">types</span><span class="p">[</span><span class="n">part</span><span class="p">])</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spaths</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">lens</span><span class="p">)))</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">sizes</span><span class="p">)</span>  <span class="c1"># total size (desired)</span></div>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="CTypeSpathsCollection.simple_types_distribution"><a class="viewcode-back" href="../../../aquaduct.geom.master.html#aquaduct.geom.master.CTypeSpathsCollection.simple_types_distribution">[docs]</a>    <span class="k">def</span> <span class="nf">simple_types_distribution</span><span class="p">(</span><span class="n">types</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Calculates normalized sizes of incoming, object, and outgoing parts of spath using generic types.</span>

<span class="sd">        It is assumed that spath has object part.</span>

<span class="sd">        :param list types: List of generic types.</span>
<span class="sd">        :rtype: 3 element list</span>
<span class="sd">        :return: Normalized sizes of incomin, object, and outgoing parts.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># possible types are:</span>
        <span class="c1"># GenericPathTypeCodes.object_name</span>
        <span class="c1"># GenericPathTypeCodes.scope_name</span>
        <span class="n">td_in</span><span class="p">,</span> <span class="n">td_obj</span><span class="p">,</span> <span class="n">td_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="n">sls</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">list_blocks_to_slices</span><span class="p">(</span><span class="n">types</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">GenericPathTypeCodes</span><span class="o">.</span><span class="n">scope_name</span> <span class="ow">in</span> <span class="n">types</span><span class="p">[</span><span class="n">sls</span><span class="p">[</span><span class="mi">0</span><span class="p">]]:</span>
            <span class="c1"># this is input part</span>
            <span class="n">td_in</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">types</span><span class="p">[</span><span class="n">sls</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
        <span class="k">if</span> <span class="n">GenericPathTypeCodes</span><span class="o">.</span><span class="n">scope_name</span> <span class="ow">in</span> <span class="n">types</span><span class="p">[</span><span class="n">sls</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]:</span>
            <span class="c1"># this is output part</span>
            <span class="n">td_out</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">types</span><span class="p">[</span><span class="n">sls</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
        <span class="c1"># the rest is object</span>
        <span class="n">td_obj</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">types</span><span class="p">)</span> <span class="o">-</span> <span class="n">td_in</span> <span class="o">-</span> <span class="n">td_out</span>
        <span class="k">return</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">types</span><span class="p">),</span> <span class="p">(</span><span class="n">td_in</span><span class="p">,</span> <span class="n">td_obj</span><span class="p">,</span> <span class="n">td_out</span><span class="p">))</span></div>

<div class="viewcode-block" id="CTypeSpathsCollection.types_distribution"><a class="viewcode-back" href="../../../aquaduct.geom.master.html#aquaduct.geom.master.CTypeSpathsCollection.types_distribution">[docs]</a>    <span class="k">def</span> <span class="nf">types_distribution</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :rtype: numpy.matrix</span>
<span class="sd">        :return: median values of :meth:`simple_types_distribution` for all spaths.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># make median distribuitions</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">make_default_array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">simple_types_distribution</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">gtypes_cont</span><span class="p">)</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spaths</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)))</span></div>

<div class="viewcode-block" id="CTypeSpathsCollection.types_prob_to_types"><a class="viewcode-back" href="../../../aquaduct.geom.master.html#aquaduct.geom.master.CTypeSpathsCollection.types_prob_to_types">[docs]</a>    <span class="k">def</span> <span class="nf">types_prob_to_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">types_prob</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Changes types probabilities as returned by :meth:`CTypeSpathsCollectionWorker.coords_types_prob_widths` to types.</span>

<span class="sd">        :param list types_prob: List of types probabilities.</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        :return: List of :class:`~aquaduct.traj.paths.GenericPathTypeCodes`.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># get proper types</span>
        <span class="n">types_dist_orig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">types_distribution</span><span class="p">()</span>
        <span class="n">types_dist_range</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">types_prob</span><span class="p">))</span>
        <span class="n">types_thresholds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">types_dist_range</span><span class="p">:</span>
            <span class="n">new_pro_types</span> <span class="o">=</span> <span class="p">[{</span><span class="kc">True</span><span class="p">:</span> <span class="n">GenericPathTypeCodes</span><span class="o">.</span><span class="n">scope_name</span><span class="p">,</span>
                              <span class="kc">False</span><span class="p">:</span> <span class="n">GenericPathTypeCodes</span><span class="o">.</span><span class="n">object_name</span><span class="p">}[</span><span class="n">typ</span> <span class="o">&gt;=</span> <span class="n">t</span><span class="p">]</span> <span class="k">for</span> <span class="n">typ</span> <span class="ow">in</span> <span class="n">types_prob</span><span class="p">]</span>
            <span class="n">types_thresholds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">make_default_array</span><span class="p">(</span><span class="n">cdist</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">simple_types_distribution</span><span class="p">(</span><span class="n">new_pro_types</span><span class="p">)),</span>
                                          <span class="n">types_dist_orig</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">beat</span><span class="p">()</span>
        <span class="c1"># get threshold for which value of types_thresholds is smallest</span>
        <span class="n">types</span> <span class="o">=</span> <span class="p">[{</span><span class="kc">True</span><span class="p">:</span> <span class="n">GenericPathTypeCodes</span><span class="o">.</span><span class="n">scope_name</span><span class="p">,</span>
                  <span class="kc">False</span><span class="p">:</span> <span class="n">GenericPathTypeCodes</span><span class="o">.</span><span class="n">object_name</span><span class="p">}[</span><span class="n">typ</span> <span class="o">&gt;=</span> <span class="n">types_dist_range</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">types_thresholds</span><span class="p">)]]</span> <span class="k">for</span> <span class="n">typ</span>
                 <span class="ow">in</span> <span class="n">types_prob</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">types</span></div>

<div class="viewcode-block" id="CTypeSpathsCollection.get_master_path"><a class="viewcode-back" href="../../../aquaduct.geom.master.html#aquaduct.geom.master.CTypeSpathsCollection.get_master_path">[docs]</a>    <span class="k">def</span> <span class="nf">get_master_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">smooth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">resid</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        .. _master_path_generation:</span>

<span class="sd">        Averages spaths into one master path.</span>

<span class="sd">        This is done in steps:</span>

<span class="sd">        #. Master path is an average of bunch of spaths. Its length is determined by :meth:`full_size` method.</span>
<span class="sd">        #. All spaths are then divided in to chunks according to :func:`~aquaduct.utils.helpers.xzip_xzip` function with :attr:`N` set to lenght of master path. This results in list of length equal to the length of master path. Elements of this lists are slice objects that can be used to slice spaths in appropriate chunks.</span>
<span class="sd">        #. Next, for each element of this list :meth:`CTypeSpathsCollectionWorker.coords_types_prob_widths` method is called. Types probabilities are changed to types wiht :meth:`types_prob_to_types`.</span>
<span class="sd">        #. Finally, all data are used to create appropriate :class:`MasterPath`. If this fails `None` is returned.</span>

<span class="sd">        :param Smooth smooth: Smoothing method.</span>
<span class="sd">        :param int resid: Residue ID of master path.</span>
<span class="sd">        :rtype: :class:`~aquaduct.traj.paths.MasterPath`</span>
<span class="sd">        :return: Average path as :class:`~aquaduct.traj.paths.MasterPath` object or `None` if creation of master path failed.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># prepare worker</span>
        <span class="n">worker</span> <span class="o">=</span> <span class="n">CTypeSpathsCollectionWorker</span><span class="p">(</span><span class="n">spaths</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spaths</span><span class="p">,</span> <span class="n">ctype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ctype</span><span class="p">,</span> <span class="n">bias_long</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bias_long</span><span class="p">,</span>
                                             <span class="n">smooth</span><span class="o">=</span><span class="n">smooth</span><span class="p">)</span>
        <span class="c1"># add some spaths precalcualted properties to worker</span>
        <span class="n">worker</span><span class="o">.</span><span class="n">lens_cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lens_cache</span>
        <span class="n">worker</span><span class="o">.</span><span class="n">lens_real_cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lens_real_cache</span>
        <span class="n">worker</span><span class="o">.</span><span class="n">lens_norm_cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lens_norm_cache</span>
        <span class="n">worker</span><span class="o">.</span><span class="n">full_size_cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_size_cache</span>

        <span class="c1"># desired full size of path</span>
        <span class="n">full_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_size_cache</span>

        <span class="c1"># containers for coords, types and widths of master path</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">full_size</span>
        <span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">full_size</span>
        <span class="n">widths</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">full_size</span>

        <span class="c1"># pbar magic</span>
        <span class="n">pbar_previous</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">pbar_factor</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spaths</span><span class="p">))</span> <span class="o">/</span> <span class="n">full_size</span>

        <span class="c1"># create pool of workers - mapping function</span>
        <span class="n">map_fun</span> <span class="o">=</span> <span class="nb">map</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">threads</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">pool</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">threads</span><span class="p">)</span>
            <span class="n">map_fun</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">imap_unordered</span>
            <span class="n">chunk_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">full_size</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">threads</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">chunk_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">chunk_size</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">map_fun</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">pool</span><span class="o">.</span><span class="n">imap_unordered</span><span class="p">,</span><span class="n">chunksize</span><span class="o">=</span><span class="n">chunk_size</span><span class="p">)</span>

        <span class="c1"># TODO: it is possible to add pbar support here!</span>
        <span class="c1"># maximal number of spath</span>
        <span class="n">spath_nr_max</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># loop over results of workers calculations on xzip_xzip lens_real with N=full_size</span>
        <span class="c1"># 1. Lens_real (sizes of spaths) are submitted to xzip_xzip wih N=full size</span>
        <span class="c1">#    For each spath there will be collection of N slices, each slice cuts some part of spath.</span>
        <span class="c1">#    In consequence, all spaths will be cutted in tho N chunks and for each path chunk will be</span>
        <span class="c1">#    of different size</span>
        <span class="c1"># 2. These slices are submitted to worker callable class.</span>
        <span class="k">for</span> <span class="n">pbar_nr</span><span class="p">,</span> <span class="p">(</span><span class="n">spath_nr</span><span class="p">,</span> <span class="p">(</span><span class="n">coords_</span><span class="p">,</span> <span class="n">types_</span><span class="p">,</span> <span class="n">widths_</span><span class="p">))</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                <span class="n">map_fun</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">xzip_xzip</span><span class="p">(</span><span class="o">*</span><span class="n">worker</span><span class="o">.</span><span class="n">lens_real_cache</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="n">full_size</span><span class="p">)))):</span>
            <span class="n">coords</span><span class="p">[</span><span class="n">spath_nr</span><span class="p">]</span> <span class="o">=</span> <span class="n">coords_</span>
            <span class="n">types</span><span class="p">[</span><span class="n">spath_nr</span><span class="p">]</span> <span class="o">=</span> <span class="n">types_</span>
            <span class="n">widths</span><span class="p">[</span><span class="n">spath_nr</span><span class="p">]</span> <span class="o">=</span> <span class="n">widths_</span>
            <span class="n">spath_nr_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">spath_nr</span><span class="p">,</span> <span class="n">spath_nr_max</span><span class="p">)</span>
            <span class="n">pbar_current</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">pbar_nr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">pbar_factor</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">pbar_current</span> <span class="o">&gt;</span> <span class="n">pbar_previous</span><span class="p">:</span>
                <span class="n">pbar_previous</span> <span class="o">=</span> <span class="n">pbar_current</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>  <span class="c1"># update progress bar</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">beat</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">pbar_nr</span> <span class="o">==</span> <span class="n">spath_nr_max</span><span class="p">,</span> <span class="s2">&quot;Internal error. Final global progress of master path generation not synced with maximal number of spath. Please send a bug report to developer(s): </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">clui</span><span class="o">.</span><span class="n">mail</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">threads</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
            <span class="n">pool</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
            <span class="k">del</span> <span class="n">pool</span>

        <span class="c1"># at this stage we have coords, widths and types probability</span>

        <span class="c1"># get proper types</span>
        <span class="k">with</span> <span class="n">clui</span><span class="o">.</span><span class="n">tictoc</span><span class="p">(</span><span class="s1">&#39;proper tests in </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctype</span><span class="p">)):</span>
            <span class="n">types</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">types_prob_to_types</span><span class="p">(</span><span class="n">types</span><span class="p">)</span>

        <span class="c1"># make frames</span>
        <span class="n">frames</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">))</span>

        <span class="c1"># finalize</span>

        <span class="c1"># max min frames</span>
        <span class="n">min_pf</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">max_pf</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># this never happens because of assertion in __init__</span>
            <span class="n">min_pf</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">max_pf</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctype</span><span class="o">.</span><span class="n">input</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">min_pf</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctype</span><span class="o">.</span><span class="n">output</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">max_pf</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">with</span> <span class="n">clui</span><span class="o">.</span><span class="n">tictoc</span><span class="p">(</span><span class="s1">&#39;generic paths in </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctype</span><span class="p">)):</span>
            <span class="c1"># get and populate GenericPath</span>
            <span class="n">gp</span> <span class="o">=</span> <span class="n">GenericPaths</span><span class="p">(</span><span class="n">resid</span><span class="p">,</span> <span class="n">min_pf</span><span class="o">=</span><span class="n">min_pf</span><span class="p">,</span> <span class="n">max_pf</span><span class="o">=</span><span class="n">max_pf</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">types</span><span class="p">,</span> <span class="n">frames</span><span class="p">):</span>  <span class="c1"># TODO: remove loop</span>
                <span class="n">gp</span><span class="o">.</span><span class="n">add_type</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
                <span class="n">gp</span><span class="o">.</span><span class="n">add_coord</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="c1"># now try to get first SinglePath, if unable issue WARNING</span>
        <span class="k">with</span> <span class="n">clui</span><span class="o">.</span><span class="n">tictoc</span><span class="p">(</span><span class="s1">&#39;separate paths in </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctype</span><span class="p">)):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">sp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">yield_single_paths</span><span class="p">([</span><span class="n">gp</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;No master path found for ctype </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctype</span><span class="p">))</span>
                <span class="k">return</span> <span class="kc">None</span>
        <span class="c1"># finally get MasterPath and add widths</span>
        <span class="n">mp</span> <span class="o">=</span> <span class="n">MasterPath</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
        <span class="n">mp</span><span class="o">.</span><span class="n">add_width</span><span class="p">(</span><span class="n">widths</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mp</span></div></div>


<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">def create_master_spath(spaths, smooth=None, resid=0, ctype=None, bias_long=5, pbar=None):</span>
<span class="sd">    def beat():</span>
<span class="sd">        if pbar is not None:</span>
<span class="sd">            pbar.heartbeat()</span>

<span class="sd">    def update():</span>
<span class="sd">        if pbar is not None:</span>
<span class="sd">            pbar.update(1)</span>

<span class="sd">    # first check what is the size of paths in all parts and normalize and then scale them</span>
<span class="sd">    sizes = []</span>
<span class="sd">    for part in parts:</span>
<span class="sd">        # lengths of all paths of part part</span>
<span class="sd">        lens = make_default_array([float(len(sp.types[part])) for sp in spaths])</span>
<span class="sd">        if np.max(lens) &gt; 0:</span>
<span class="sd">            lens /= np.max(lens)  # normalization</span>
<span class="sd">            lens = lens ** bias_long  # scale them by increasing weights of long paths</span>
<span class="sd">        if sum(lens) == 0:</span>
<span class="sd">            sizes.append(0)</span>
<span class="sd">        else:</span>
<span class="sd">            # weighted average by paths lengths</span>
<span class="sd">            sizes.append(int(np.average([len(sp.types[part]) for sp in spaths], 0, lens)))</span>
<span class="sd">        beat()</span>
<span class="sd">    full_size = sum(sizes)  # total size (desired)</span>
<span class="sd">    pbar_factor = float(len(spaths)) / full_size</span>

<span class="sd">    # get total lenghts of all paths - needed as weights in averaging</span>
<span class="sd">    lens = make_default_array([float(sp.size) for sp in spaths])</span>
<span class="sd">    # if ctype in #:# and not 0 and not None then take object part only length</span>
<span class="sd">    if ctype is not None:</span>
<span class="sd">        if ctype.input is not None:</span>
<span class="sd">            if ctype.input &gt; 0:</span>
<span class="sd">                if ctype.input == ctype.output:</span>
<span class="sd">                    lens = make_default_array([float(len(sp.types_object)) for sp in spaths])</span>
<span class="sd">    # normalize and incearse weight of long paths (depends ob ctype)</span>
<span class="sd">    if np.max(lens) &gt; 0:</span>
<span class="sd">        lens /= np.max(lens)  # normalize</span>
<span class="sd">        lens = lens ** bias_long  # bias to long paths</span>

<span class="sd">    # containers for coords, types and widths of master path</span>
<span class="sd">    coords = []</span>
<span class="sd">    types = []</span>
<span class="sd">    widths = []</span>
<span class="sd">    pbar_previous = 0</span>

<span class="sd">    # following loop calculates types distribution only</span>
<span class="sd">    # loop over zip zipped [smooth] coords of all paths and gtypes with size set to full_size</span>
<span class="sd">    for pbar_nr, (coords_zz, types_zz) in enumerate(</span>
<span class="sd">            zip(zip_zip(*[sp.get_coords_cont(smooth=smooth) for sp in spaths], N=full_size),</span>
<span class="sd">                zip_zip(*[sp.gtypes_cont for sp in spaths], N=full_size))):</span>
<span class="sd">        # make lens_zz which are lens corrected to the lenghts of coords_zz and normalized to zip_zip number of obejcts</span>
<span class="sd">        lens_zz = []</span>
<span class="sd">        for l, coord_z in zip(lens, coords_zz):</span>
<span class="sd">            if len(coord_z) &gt; 0:</span>
<span class="sd">                lens_zz.append([float(l) / len(coord_z)] * len(coord_z))  # normalize and correct lengths</span>
<span class="sd">            else:</span>
<span class="sd">                # lens_zz.append([float(l)] * len(coord_z))</span>
<span class="sd">                lens_zz.append([])</span>
<span class="sd">        # concatenate zip_zip coords and lens</span>
<span class="sd">        coords_zz_cat = list(concatenate(*coords_zz))</span>
<span class="sd">        lens_zz_cat = list(concatenate(*lens_zz))</span>
<span class="sd">        # average coords_zz_cat using weights of lens_zz_cat</span>
<span class="sd">        coords.append(make_default_array(np.average(coords_zz_cat, 0, lens_zz_cat)))</span>
<span class="sd">        # calculate widths</span>
<span class="sd">        if len(coords_zz) &gt; 1:</span>
<span class="sd">            # try tu use weighted distance - wminkowski with p=2 is equivalent to weighted euclidean</span>
<span class="sd">            # id_of_max = np.argmax(pdist(coords_zz_cat, &#39;wminkowski&#39;, p=2, w=lens_zz_cat))</span>
<span class="sd">            # widths.append(pdist(coords_zz_cat, &#39;euclidean&#39;)[id_of_max])</span>
<span class="sd">            widths.append(np.mean(pdist(coords_zz_cat, &#39;euclidean&#39;)))</span>
<span class="sd">        else:</span>
<span class="sd">            widths.append(0.)</span>
<span class="sd">        # concatenate zip_zip gtypes</span>
<span class="sd">        types_zz_cat = list(concatenate(*types_zz))</span>
<span class="sd">        # # pick correct type..., check distance of coords[-1] to coords_zz_cat</span>
<span class="sd">        # types_cdist = cdist(np.matrix(coords[-1]), coords_zz_cat, metric=&#39;euclidean&#39;)</span>
<span class="sd">        # types.append(types_zz_cat[np.argmin(types_cdist)])</span>
<span class="sd">        # types.append(decide_on_type(Counter(types_zz_cat)))</span>
<span class="sd">        types.append(float(types_zz_cat.count(GenericPathTypeCodes.scope_name)) / len(types_zz_cat))</span>

<span class="sd">        pbar_current = int((pbar_nr + 1) * pbar_factor)</span>
<span class="sd">        if pbar_current &gt; pbar_previous:</span>
<span class="sd">            pbar_previous = pbar_current</span>
<span class="sd">            update()  # update progress bar</span>
<span class="sd">        else:</span>
<span class="sd">            beat()</span>
<span class="sd">    # get proper types</span>
<span class="sd">    # make median distribuitions</span>
<span class="sd">    types_dist_orig = np.matrix(np.median([CTypeSpathsCollection.simple_types_distribution(sp.gtypes_cont) for sp in spaths], axis=0),dtype=defaults.float_default)</span>
<span class="sd">    types_dist_range = list(set(types))</span>
<span class="sd">    types_thresholds = []</span>
<span class="sd">    for t in types_dist_range:</span>
<span class="sd">        new_pro_types = [{True: GenericPathTypeCodes.scope_name,</span>
<span class="sd">                          False: GenericPathTypeCodes.object_name}[typ &gt;= t] for typ in types]</span>
<span class="sd">        types_thresholds.append(make_default_array(cdist(np.matrix(CTypeSpathsCollection.simple_types_distribution(new_pro_types)),</span>
<span class="sd">                                      types_dist_orig, metric=&#39;euclidean&#39;)))</span>
<span class="sd">        beat()</span>
<span class="sd">    # get threshold for which value of types_thresholds is smallest</span>
<span class="sd">    types = [{True: GenericPathTypeCodes.scope_name,</span>
<span class="sd">              False: GenericPathTypeCodes.object_name}[typ &gt;= types_dist_range[np.argmin(types_thresholds)]] for typ in</span>
<span class="sd">             types]</span>

<span class="sd">    frames = range(len(coords))</span>

<span class="sd">    min_pf = 0</span>
<span class="sd">    max_pf = len(coords) - 1</span>

<span class="sd">    if ctype is None:</span>
<span class="sd">        min_pf = None</span>
<span class="sd">        max_pf = None</span>
<span class="sd">    else:</span>
<span class="sd">        if ctype.input is not None:</span>
<span class="sd">            min_pf = None</span>
<span class="sd">        if ctype.output is not None:</span>
<span class="sd">            max_pf = None</span>

<span class="sd">    gp = GenericPaths(resid, min_pf=min_pf, max_pf=max_pf)</span>
<span class="sd">    for c, t, f in zip(coords, types, frames):  # TODO: remove loop</span>
<span class="sd">        gp.add_type(f, t)</span>
<span class="sd">        gp.add_coord(c)</span>
<span class="sd">        beat()</span>
<span class="sd">    # return gp</span>
<span class="sd">    beat()  # touch progress bar</span>
<span class="sd">    try:</span>
<span class="sd">        sp = list(yield_single_paths([gp]))[0]</span>
<span class="sd">    except IndexError:</span>
<span class="sd">        logger.warning(&#39;No master path found for ctype %s&#39; % str(ctype))</span>
<span class="sd">        return None</span>
<span class="sd">    beat()  # touch progress bar</span>
<span class="sd">    mp = MasterPath(sp)</span>
<span class="sd">    mp.add_width(widths)</span>
<span class="sd">    return mp</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">def calculate_master(spaths_resid_ctype_smooth):</span>
<span class="sd">    spaths, resid, ctype, smooth = spaths_resid_ctype_smooth</span>
<span class="sd">    return CTypeSpathsCollection(spaths=spaths, ctype=ctype).get_master_path(smooth=smooth, resid=resid)</span>

<span class="sd">&#39;&#39;&#39;</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Aqua-Duct 0.3.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../aquaduct.html" >aquaduct</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, 2017, Tomasz Magdziarz, Karolina Mitusińska, Sandra Gołdowska, Alicja Płuciennik, Michał Stolarczyk, Magdalena Ługowska, Artur Góra.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.1.
    </div>
  </body>
</html>