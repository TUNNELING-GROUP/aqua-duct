

<!doctype html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>aquaduct.geom.traces &#8212; Aqua-Duct 0.2.26 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/bizstyle.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.2.26',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../../_static/bizstyle.js"></script>
    <link rel="shortcut icon" href="../../../_static/ficon.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <!--[if lt IE 9]>
    <script type="text/javascript" src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Aqua-Duct 0.2.26 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../aquaduct.html" accesskey="U">aquaduct</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/AQUADUCT_LOGO.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for aquaduct.geom.traces</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>

<span class="c1"># Aqua-Duct, a tool facilitating analysis of the flow of solvent molecules in molecular dynamic simulations</span>
<span class="c1"># Copyright (C) 2016  Tomasz Magdziarz, Alicja Płuciennik, Michał Stolarczyk &lt;info@aquaduct.pl&gt;</span>
<span class="c1">#</span>
<span class="c1"># This program is free software: you can redistribute it and/or modify</span>
<span class="c1"># it under the terms of the GNU General Public License as published by</span>
<span class="c1"># the Free Software Foundation, either version 3 of the License, or</span>
<span class="c1"># (at your option) any later version.</span>
<span class="c1">#</span>
<span class="c1"># This program is distributed in the hope that it will be useful,</span>
<span class="c1"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1"># GNU General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU General Public License</span>
<span class="c1"># along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="k">import</span> <span class="n">pdist</span>


<span class="c1">################################################################################</span>
<span class="c1"># traces utils and helpers</span>

<div class="viewcode-block" id="diff"><a class="viewcode-back" href="../../../aquaduct.geom.traces.html#aquaduct.geom.traces.diff">[docs]</a><span class="k">def</span> <span class="nf">diff</span><span class="p">(</span><span class="n">trace</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function calculates the distance between 2 given points.</span>

<span class="sd">    :param trace: coordinates in numpy array object</span>
<span class="sd">    :return: distance between points</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># trace - 3D coordinates</span>
    <span class="c1"># returns distances between coordinates</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">),</span> <span class="s2">&quot;Trace should be of np.ndarray type, </span><span class="si">%r</span><span class="s2"> submited instead.&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">trace</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;Traces should be 2d, </span><span class="si">%d</span><span class="s2">d submited instead (trace no. </span><span class="si">%d</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">trace</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="n">trace_diff</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">nr</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">trace</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">trace_diff</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">pdist</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">row</span><span class="p">,</span> <span class="n">trace</span><span class="p">[</span><span class="n">nr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])),</span> <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">)))</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">trace_diff</span><span class="p">)</span></div>


<div class="viewcode-block" id="tracepoints"><a class="viewcode-back" href="../../../aquaduct.geom.traces.html#aquaduct.geom.traces.tracepoints">[docs]</a><span class="k">def</span> <span class="nf">tracepoints</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">nr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :param start: coordinates of the first point as a numpy array object</span>
<span class="sd">    :param stop: coordinates of the second point as a numpy array object</span>
<span class="sd">    :param nr: number of elements between the first and second point</span>
<span class="sd">    :return: two-dimentional numpy array; number of dimentions depends on nr parameter</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># returns points between start and stop as linear interpolations</span>
    <span class="c1"># if nr == 1 then midpoint is returned</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="n">ce</span><span class="p">,</span> <span class="n">nr</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">cb</span><span class="p">,</span> <span class="n">ce</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)])</span><span class="o">.</span><span class="n">T</span></div>


<div class="viewcode-block" id="midpoints"><a class="viewcode-back" href="../../../aquaduct.geom.traces.html#aquaduct.geom.traces.midpoints">[docs]</a><span class="k">def</span> <span class="nf">midpoints</span><span class="p">(</span><span class="n">paths</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The function returns a tuple of numpy arrays extended with mid point spanning last and first element(column)</span>
<span class="sd">     of these arrays.</span>

<span class="sd">    :param paths: a tuple of 2-dimentional np.arrays that hold 3D coordinates; each element holds one trace, all elements are supposed to make one path divided in to sections</span>
<span class="sd">    :return: paths elements with additional mid points as a generator object</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># paths - a tuple of 2d np.arrays that hold 3D coordinates, each element holds one trace, all elements are supposed to make one path divided in to sections</span>
    <span class="c1"># yields paths elements with additional mid points</span>
    <span class="c1"># if input paths is follwoing:</span>
    <span class="c1">#   11111 33333 55555</span>
    <span class="c1"># function yields the same elements plus midpoints:</span>
    <span class="c1">#   111112 2333334 455555</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">paths</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">),</span> <span class="s2">&quot;Paths should be of tuple type, </span><span class="si">%r</span><span class="s2"> submitted instead.&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">paths</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">nr</span><span class="p">,</span> <span class="n">trace</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">paths</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span>
                          <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">),</span> <span class="s2">&quot;Traces should be of numpy.ndarray type, </span><span class="si">%r</span><span class="s2"> submited instead (trace no. </span><span class="si">%d</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="nb">type</span><span class="p">(</span><span class="n">trace</span><span class="p">),</span> <span class="n">nr</span><span class="p">)</span>
        <span class="c1"># assert len(trace.shape) == 2, &quot;Traces should be 2d, %dd submited instead (trace no. %d)&quot; %(len(trace.shape),nr)</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">paths</span><span class="p">)</span>
    <span class="n">last_trace</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">nr</span><span class="p">,</span> <span class="n">trace</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">paths</span><span class="p">):</span>
            <span class="c1"># find past and next trace</span>
            <span class="n">past</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="n">nr</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">paths</span><span class="p">[</span><span class="n">nr</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">past</span> <span class="o">=</span> <span class="n">paths</span><span class="p">[</span><span class="n">nr</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">next_trace</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="n">nr</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">paths</span><span class="p">[</span><span class="n">nr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">next_trace</span> <span class="o">=</span> <span class="n">paths</span><span class="p">[</span><span class="n">nr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># calculate midpoints if relevant</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">trace</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">past</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">midp</span> <span class="o">=</span> <span class="n">tracepoints</span><span class="p">(</span><span class="n">past</span><span class="p">,</span> <span class="n">trace</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">trace</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">midp</span><span class="p">,</span> <span class="n">trace</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">next_trace</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">midp</span> <span class="o">=</span> <span class="n">tracepoints</span><span class="p">(</span><span class="n">trace</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">next_trace</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">trace</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">trace</span><span class="p">,</span> <span class="n">midp</span><span class="p">))</span>
            <span class="k">yield</span> <span class="n">trace</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">paths</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="length_step_std"><a class="viewcode-back" href="../../../aquaduct.geom.traces.html#aquaduct.geom.traces.length_step_std">[docs]</a><span class="k">def</span> <span class="nf">length_step_std</span><span class="p">(</span><span class="n">trace</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function calculates sum, mean and standard deviation from all segments of a trace.</span>

<span class="sd">    :param trace: coordinates of points as numpy array</span>
<span class="sd">    :return: a tuple with basics statistics of a trace</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># trace - 3D coordinates</span>
    <span class="c1"># calculates diff over trace and returns sum, mean and std of diff</span>
    <span class="c1"># if trace is empty or have length &lt; 2 nans are returned</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">trace</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">trace</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">d</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">d</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">d</span><span class="p">)</span></div>


<div class="viewcode-block" id="derrivative"><a class="viewcode-back" href="../../../aquaduct.geom.traces.html#aquaduct.geom.traces.derrivative">[docs]</a><span class="k">def</span> <span class="nf">derrivative</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
    <span class="c1"># values - 3D coordinates</span>
    <span class="c1"># calculates derrivative of lenght of trace</span>
    <span class="c1"># uses diff but yields the same number of values as in input data</span>
    <span class="c1"># this is done by interpolation and applying simple correction</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
    <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span>
    <span class="n">correction</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># this correct values so after integration they are closer to expected value</span>
    <span class="c1"># This was calculated by following experiment:</span>
    <span class="c1"># w = []</span>
    <span class="c1"># for q in range(10000):</span>
    <span class="c1">#     r = np.cumsum(np.random.rand(10000))</span>
    <span class="c1">#     w.append(r[-1]/sum(list(traces.derrivative(r))))</span>
    <span class="c1"># np.mean(w) # w is of narmal distribution</span>

    <span class="k">for</span> <span class="n">nr</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">nr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">diff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">correction</span>  <span class="c1"># begin</span>
        <span class="k">elif</span> <span class="n">nr</span> <span class="o">==</span> <span class="n">size</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">diff</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">correction</span>  <span class="c1"># end</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">yield</span> <span class="p">(</span><span class="n">diff</span><span class="p">[</span><span class="n">nr</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">diff</span><span class="p">[</span><span class="n">nr</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.</span> <span class="o">-</span> <span class="n">correction</span></div>


<span class="c1"># todo : aby zaoszczedzic na obliczeniach mozna pomijac takie katy(lub zwracac 0), ktorych zwracane wartosci są bardzo,bardzo małe (rzedu np 10**-4)-&gt; np kat 0.005 rad to 0,29stopnia miary łukowej</span>
<span class="c1"># wektory: promień atomu wodoru to 0.529A</span>

<span class="c1">################################################################################</span>
<span class="c1"># vectors, triangles and angles helpers</span>

<div class="viewcode-block" id="vector_norm"><a class="viewcode-back" href="../../../aquaduct.geom.traces.html#aquaduct.geom.traces.vector_norm">[docs]</a><span class="k">def</span> <span class="nf">vector_norm</span><span class="p">(</span><span class="n">V</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    :param V: a vector in a form of array-like object, tuple or a list</span>
<span class="sd">    :return: normalized length of a vector</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># calculate length of physical vector based on it&#39;s coordinates</span>
    <span class="c1"># input: tuple or a list</span>
    <span class="c1"># output: float</span>
    <span class="c1"># return np.sqrt(np.dot(V, V.conj()))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">V</span><span class="p">))</span></div>
    <span class="c1"># return np.linalg.norm(V)</span>


<div class="viewcode-block" id="triangle_angles"><a class="viewcode-back" href="../../../aquaduct.geom.traces.html#aquaduct.geom.traces.triangle_angles">[docs]</a><span class="k">def</span> <span class="nf">triangle_angles</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameters are coordinates of points which are tops of triangle. The function calculates angles in a triangle formed by given coordinates.</span>

<span class="sd">    :param A: coordinates of the first point</span>
<span class="sd">    :param B: coordinates of the second point</span>
<span class="sd">    :param C: coordinates of the third point</span>
<span class="sd">    :return: list of arguments where angle is given in radians , the output is as follow: [BAC,CAB,ABC]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># http://stackoverflow.com/questions/5122372/angle-between-points</span>
    <span class="c1"># A,B,C are point in the space</span>
    <span class="c1"># input: 3 space coords of points (as tuple or list)</span>
    <span class="c1"># returns list of arguments where angle is given in radians , the output is as follow: [BAC,CAB,ABC]</span>
    <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">))</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">C</span> <span class="o">-</span> <span class="n">A</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">B</span> <span class="o">-</span> <span class="n">A</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">C</span> <span class="o">-</span> <span class="n">B</span>
    <span class="n">angles</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span> <span class="ow">in</span> <span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">),</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="o">-</span><span class="n">c</span><span class="p">)):</span>
        <span class="n">num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">)</span>
        <span class="n">denom</span> <span class="o">=</span> <span class="n">vector_norm</span><span class="p">(</span><span class="n">e1</span><span class="p">)</span> <span class="o">*</span> <span class="n">vector_norm</span><span class="p">(</span><span class="n">e2</span><span class="p">)</span>
        <span class="n">angles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">num</span> <span class="o">/</span> <span class="n">denom</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>  <span class="c1"># cliping values in to [-1,1]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">angles</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">angles</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="k">return</span> <span class="n">angles</span></div>


<div class="viewcode-block" id="triangle_angles_last"><a class="viewcode-back" href="../../../aquaduct.geom.traces.html#aquaduct.geom.traces.triangle_angles_last">[docs]</a><span class="k">def</span> <span class="nf">triangle_angles_last</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameters are coordinates of points which are tops of triangle. The function calculates the [ABC] angle.</span>

<span class="sd">    :param A: coordinates of the first point [A top]</span>
<span class="sd">    :param B: coordinates of the second point [B top]</span>
<span class="sd">    :param C: coordinates of the third point [C top]</span>
<span class="sd">    :return: list with one value of ABC angle in radians</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># http://stackoverflow.com/questions/5122372/angle-between-points</span>
    <span class="c1"># A,B,C are point in the space</span>
    <span class="c1"># input: 3 space coords of points (as tuple or list)</span>
    <span class="c1"># returns list with one value of ABC angle in radians</span>
    <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">))</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">C</span> <span class="o">-</span> <span class="n">A</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">B</span> <span class="o">-</span> <span class="n">A</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">C</span> <span class="o">-</span> <span class="n">B</span>
    <span class="n">angles</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span> <span class="ow">in</span> <span class="p">((</span><span class="n">b</span><span class="p">,</span> <span class="o">-</span><span class="n">c</span><span class="p">),):</span>
        <span class="n">num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">)</span>
        <span class="n">denom</span> <span class="o">=</span> <span class="n">vector_norm</span><span class="p">(</span><span class="n">e1</span><span class="p">)</span> <span class="o">*</span> <span class="n">vector_norm</span><span class="p">(</span><span class="n">e2</span><span class="p">)</span>
        <span class="n">angles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">num</span> <span class="o">/</span> <span class="n">denom</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>  <span class="c1"># cliping values in to [-1,1]</span>
    <span class="k">return</span> <span class="n">angles</span></div>


<div class="viewcode-block" id="triangle_height"><a class="viewcode-back" href="../../../aquaduct.geom.traces.html#aquaduct.geom.traces.triangle_height">[docs]</a><span class="k">def</span> <span class="nf">triangle_height</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameters are coordinates of points which are tops of triangle. The function calculates the ABC triangle height.</span>

<span class="sd">    :param A: coordinates of the first point [A top]</span>
<span class="sd">    :param B: coordinates of the second point [B top]</span>
<span class="sd">    :param C: coordinates of the third point [C top]</span>
<span class="sd">    :return: one value of ABC triangle height</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># a is head</span>
    <span class="c1"># input: 3 space coords of points (as tuple or list)</span>
    <span class="c1"># output float, value of triangle height</span>
    <span class="n">angles</span> <span class="o">=</span> <span class="n">triangle_angles_last</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span>  <span class="c1"># ta funkcja zwraca tylko 1 element</span>
    <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">))</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">vector_norm</span><span class="p">(</span><span class="n">B</span> <span class="o">-</span> <span class="n">A</span><span class="p">)</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angles</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">c</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">h</span><span class="p">):</span>
        <span class="n">h</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="k">return</span> <span class="n">h</span></div>


<div class="viewcode-block" id="vectors_angle"><a class="viewcode-back" href="../../../aquaduct.geom.traces.html#aquaduct.geom.traces.vectors_angle">[docs]</a><span class="k">def</span> <span class="nf">vectors_angle</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function calculates the angle between two given vectors (starting from the [0,0,0] to the given coordinates.</span>

<span class="sd">    :param A: coordinates of the first point which is the end of the vector</span>
<span class="sd">    :param B: coordinates of the second point which is the end of the vector</span>
<span class="sd">    :return: the angle between vectors in question (in radians)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">vector_norm</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">*</span> <span class="n">vector_norm</span><span class="p">(</span><span class="n">B</span><span class="p">)))</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">angle</span><span class="p">):</span>
        <span class="k">return</span> <span class="mf">0.0</span>
    <span class="k">return</span> <span class="n">angle</span></div>


<div class="viewcode-block" id="vectors_angle_alt"><a class="viewcode-back" href="../../../aquaduct.geom.traces.html#aquaduct.geom.traces.vectors_angle_alt">[docs]</a><span class="k">def</span> <span class="nf">vectors_angle_alt</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function calculates the angle between two given vectors (starting from the [0,0,0] to the given coordinates</span>
<span class="sd">     - alternative method.</span>

<span class="sd">    :param A: coordinates of the first point which is the end of the vector</span>
<span class="sd">    :param B: coordinates of the second point which is the end of the vector</span>
<span class="sd">    :return: the angle between vectors in question (in radians)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span> <span class="o">/</span> <span class="n">vector_norm</span><span class="p">(</span><span class="n">A</span><span class="p">),</span> <span class="n">B</span> <span class="o">/</span> <span class="n">vector_norm</span><span class="p">(</span><span class="n">B</span><span class="p">)),</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))</span></div>


<div class="viewcode-block" id="vectors_angle_alt_anorm"><a class="viewcode-back" href="../../../aquaduct.geom.traces.html#aquaduct.geom.traces.vectors_angle_alt_anorm">[docs]</a><span class="k">def</span> <span class="nf">vectors_angle_alt_anorm</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">A_norm</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function calculates the angle between two given vectors (starting from the [0,0,0] to the given coordinates</span>
<span class="sd">     - alternative method with additional A_norm holding norm of A.</span>

<span class="sd">    :param A: coordinates of the first point which is the end of the vector</span>
<span class="sd">    :param B: coordinates of the second point which is the end of the vector</span>
<span class="sd">    :param A_norm: additional parameter holding normalized of vector A</span>
<span class="sd">    :return: the angle between vectors in question (in radians)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span> <span class="o">/</span> <span class="n">A_norm</span><span class="p">,</span> <span class="n">B</span> <span class="o">/</span> <span class="n">vector_norm</span><span class="p">(</span><span class="n">B</span><span class="p">)),</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))</span></div>


<div class="viewcode-block" id="vectors_angle_anorm"><a class="viewcode-back" href="../../../aquaduct.geom.traces.html#aquaduct.geom.traces.vectors_angle_anorm">[docs]</a><span class="k">def</span> <span class="nf">vectors_angle_anorm</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">A_norm</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function calculates the angle between two given vectors (starting from the [0,0,0] to the given coordinates</span>
<span class="sd">     using additional A_norm holding norm of A.</span>

<span class="sd">    :param A: coordinates of the first point which is the end of the vector</span>
<span class="sd">    :param B: coordinates of the second point which is the end of the vector</span>
<span class="sd">    :param A_norm: additional parameter holding normalized of vector A</span>
<span class="sd">    :return: the angle between vectors in question (in radians)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">norm2</span> <span class="o">=</span> <span class="n">A_norm</span> <span class="o">*</span> <span class="n">vector_norm</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">norm2</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.</span>
    <span class="n">angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span> <span class="o">/</span> <span class="n">norm2</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">angle</span><span class="p">):</span>
        <span class="k">return</span> <span class="mf">0.</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span></div>


<span class="c1">################################################################################</span>
<span class="c1"># Linearization classes</span>

<span class="c1"># poprawiony algorytm</span>
<div class="viewcode-block" id="LinearizeOneWay"><a class="viewcode-back" href="../../../aquaduct.geom.traces.html#aquaduct.geom.traces.LinearizeOneWay">[docs]</a><span class="k">class</span> <span class="nc">LinearizeOneWay</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<div class="viewcode-block" id="LinearizeOneWay.here"><a class="viewcode-back" href="../../../aquaduct.geom.traces.html#aquaduct.geom.traces.LinearizeOneWay.here">[docs]</a>    <span class="k">def</span> <span class="nf">here</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coords</span><span class="p">):</span>
        <span class="c1"># coords - 3D coordintates of a trace</span>
        <span class="c1"># yields indices of coords which is a staring point of linear fragments of the trace and the next point after</span>
        <span class="c1"># enf of linear segment; done in one way</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function simplifies the trace by removing the redundant, linear points</span>
<span class="sd">        :param coords: 3D coordinates of a trace as an array-like object</span>
<span class="sd">        :return: indices of coordinates which are a staring and ending points of linear fragments and other non-linear</span>
<span class="sd">        points of the trace</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="k">yield</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">yield</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span> <span class="o">-</span> <span class="mi">2</span><span class="p">):</span>
                <span class="n">ep</span> <span class="o">=</span> <span class="n">sp</span> <span class="o">+</span> <span class="mi">3</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_linear</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="n">sp</span><span class="p">:</span><span class="n">ep</span><span class="p">]):</span>
                    <span class="k">continue</span>
                <span class="k">yield</span> <span class="n">sp</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">continue</span>
            <span class="k">yield</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span></div></div>


<div class="viewcode-block" id="LinearizeHobbit"><a class="viewcode-back" href="../../../aquaduct.geom.traces.html#aquaduct.geom.traces.LinearizeHobbit">[docs]</a><span class="k">class</span> <span class="nc">LinearizeHobbit</span><span class="p">(</span><span class="n">LinearizeOneWay</span><span class="p">):</span>
<div class="viewcode-block" id="LinearizeHobbit.and_back_again"><a class="viewcode-back" href="../../../aquaduct.geom.traces.html#aquaduct.geom.traces.LinearizeHobbit.and_back_again">[docs]</a>    <span class="k">def</span> <span class="nf">and_back_again</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coords</span><span class="p">):</span>
        <span class="c1"># coords - 3D coordintates of a trace</span>
        <span class="c1"># yields indices of coords that spans linear fragments of the trace; done in opposite way than in one way</span>
        <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">size</span> <span class="o">-</span> <span class="n">e</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">here</span><span class="p">(</span><span class="n">coords</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span></div>

<div class="viewcode-block" id="LinearizeHobbit.__call__"><a class="viewcode-back" href="../../../aquaduct.geom.traces.html#aquaduct.geom.traces.LinearizeHobbit.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coords</span><span class="p">):</span>
        <span class="c1"># coords - 3D coordintates of a trace</span>
        <span class="c1"># wrapper that uses here and and_back_again methods to get merged uniq and sorted indices of coords that spans linear fragments of the trace</span>
        <span class="c1"># returns these points from coords that are linear simplification of coords</span>
        <span class="c1"># __call__ is required by child classes</span>
        <span class="n">here</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">here</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="n">and_back_again</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">and_back_again</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="n">linearize</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">here</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">and_back_again</span><span class="p">))))</span>
        <span class="k">return</span> <span class="n">coords</span><span class="p">[</span><span class="n">linearize</span><span class="p">]</span></div></div>


<div class="viewcode-block" id="LinearizeRecursive"><a class="viewcode-back" href="../../../aquaduct.geom.traces.html#aquaduct.geom.traces.LinearizeRecursive">[docs]</a><span class="k">class</span> <span class="nc">LinearizeRecursive</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for linearization methods classes.</span>

<span class="sd">    It implements recursive algorithm.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="LinearizeRecursive.here"><a class="viewcode-back" href="../../../aquaduct.geom.traces.html#aquaduct.geom.traces.LinearizeRecursive.here">[docs]</a>    <span class="k">def</span> <span class="nf">here</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Core of recursive linearization argorithm.</span>

<span class="sd">        It checks if the first, the last and the middle point are linear according to the criterion. The middle point is a selected point that is in the middle of length of the paths made by input coordinates.</span>

<span class="sd">        If these points are linear their indices are returned. Otherwise, coordinates are split into two parts. First part spans points from the first point to the middle point (inclusive) and the second part spans points from the middle (inclusive) to the last point. Next, these two parts are submitted recursively to :meth:`here`.</span>

<span class="sd">        Results of these recursive calls are joined, redundant indices are removed and sorted result is returned.</span>

<span class="sd">        :param numpy.ndarray coords: Input coordinates.</span>
<span class="sd">        :param int depth: Depth of recurence.</span>
<span class="sd">        :return: Indices of ``coords`` points that can be used instead of all points in visulatization.</span>
<span class="sd">        :rtype: list of int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># klasa nie ma zdefiniowanej metody is_linear</span>
        <span class="n">depth</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(([</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">coords</span><span class="p">))))</span>
        <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lengths</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="n">sp</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">ep</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">mp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">lengths</span> <span class="o">&gt;</span> <span class="nb">max</span><span class="p">(</span><span class="n">lengths</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">mp</span> <span class="o">==</span> <span class="n">sp</span><span class="p">:</span>
            <span class="n">mp</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">mp</span> <span class="o">==</span> <span class="n">ep</span><span class="p">:</span>
            <span class="n">mp</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_linear</span><span class="p">(</span><span class="n">coords</span><span class="p">[[</span><span class="n">sp</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">ep</span><span class="p">]],</span> <span class="n">depth</span><span class="o">=</span><span class="n">depth</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">sp</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">ep</span><span class="p">]</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span>
            <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">here</span><span class="p">(</span><span class="n">coords</span><span class="p">[:</span><span class="n">mp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">depth</span><span class="o">=</span><span class="n">depth</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">e</span> <span class="o">+</span> <span class="n">mp</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">here</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="n">mp</span><span class="p">:],</span> <span class="n">depth</span><span class="o">=</span><span class="n">depth</span><span class="p">)])))</span></div>

<div class="viewcode-block" id="LinearizeRecursive.__call__"><a class="viewcode-back" href="../../../aquaduct.geom.traces.html#aquaduct.geom.traces.LinearizeRecursive.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coords</span><span class="p">):</span>
        <span class="c1"># returns these points from coords that are linear simplification of coords</span>
        <span class="c1"># __call__ is required by child classes</span>
        <span class="n">here</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">here</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">coords</span><span class="p">[</span><span class="n">here</span><span class="p">]</span></div></div>


<span class="c1">################################################################################</span>
<span class="c1"># Linearize criteria</span>

<div class="viewcode-block" id="TriangleLinearize"><a class="viewcode-back" href="../../../aquaduct.geom.traces.html#aquaduct.geom.traces.TriangleLinearize">[docs]</a><span class="k">class</span> <span class="nc">TriangleLinearize</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<div class="viewcode-block" id="TriangleLinearize.__init__"><a class="viewcode-back" href="../../../aquaduct.geom.traces.html#aquaduct.geom.traces.TriangleLinearize.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
        <span class="c1"># threshold - maximal allowed sum of heights of triangles made of beginning, end and all middle points</span>
        <span class="c1">## bardzo ostre kryterium!!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span> <span class="o">=</span> <span class="n">threshold</span></div>

<div class="viewcode-block" id="TriangleLinearize.is_linear"><a class="viewcode-back" href="../../../aquaduct.geom.traces.html#aquaduct.geom.traces.TriangleLinearize.is_linear">[docs]</a>    <span class="k">def</span> <span class="nf">is_linear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># coords - 3D coordintates of a trace</span>
        <span class="c1"># returns True if coords make a straight line</span>
        <span class="c1"># criterion of linearity:</span>
        <span class="c1"># if sum of heights of triangles made of beginning, end and all middle points does not exceed threshold coords are linear</span>
        <span class="n">list_of_h</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">head</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">list_of_h</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">triangle_height</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">coords</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
            <span class="c1"># print list_of_h, sum(list_of_h)</span>
            <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">list_of_h</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span></div></div>


<div class="viewcode-block" id="VectorLinearize"><a class="viewcode-back" href="../../../aquaduct.geom.traces.html#aquaduct.geom.traces.VectorLinearize">[docs]</a><span class="k">class</span> <span class="nc">VectorLinearize</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for linearization methods classes.</span>

<span class="sd">    It implements vector linearization criterion.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="VectorLinearize.__init__"><a class="viewcode-back" href="../../../aquaduct.geom.traces.html#aquaduct.geom.traces.VectorLinearize.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">treshold</span><span class="o">=</span><span class="mf">0.05236</span><span class="p">):</span>
        <span class="c1"># TODO: Add docs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">treshold</span> <span class="o">=</span> <span class="n">treshold</span></div>

<div class="viewcode-block" id="VectorLinearize.is_linear_core"><a class="viewcode-back" href="../../../aquaduct.geom.traces.html#aquaduct.geom.traces.VectorLinearize.is_linear_core">[docs]</a>    <span class="k">def</span> <span class="nf">is_linear_core</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method checks if input coordinates are linear according to the threshold and depth.</span>

<span class="sd">        It begins with calculation of the threshold. If `depth` is None it is set to 1. Current threshold is calculated with following simple equation:</span>

<span class="sd">        .. math::</span>

<span class="sd">            threshold_{current} = threshold_{initial} * (2 - 0.9^{depth})</span>

<span class="sd">        Next, in a loop over all points but the first and the last the angle is calculated between two vectors. The first one made by the point and the first point, and the second vector made by the last and the first point. If any of the calculated angles is bigger the the treshold methods returns False; otherwise method returns True.</span>

<span class="sd">        :param numpy.ndarray coords: Coordinates for which linearization criterion is checked.</span>
<span class="sd">        :param int depth: Depth of recurence.</span>
<span class="sd">        :return: True if input coordinates are linear and False otherwise.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">depth</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">depth</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="n">treshold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">treshold</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">treshold</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mf">0.9</span> <span class="o">**</span> <span class="n">depth</span><span class="p">)</span>  <span class="c1"># FIXME: magic constant!</span>

        <span class="n">V</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">V_norm</span> <span class="o">=</span> <span class="n">vector_norm</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">cp</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">V_sum</span> <span class="o">=</span> <span class="n">cp</span> <span class="o">-</span> <span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">vectors_angle_anorm</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">V_sum</span><span class="p">,</span> <span class="n">V_norm</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">treshold</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="VectorLinearize.is_linear"><a class="viewcode-back" href="../../../aquaduct.geom.traces.html#aquaduct.geom.traces.VectorLinearize.is_linear">[docs]</a>    <span class="k">def</span> <span class="nf">is_linear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For more detail see :meth:`is_linear_core` which is used as the criterion of linearity in this method.</span>

<span class="sd">        :param numpy.ndarray coords: Coordinates for which linearization criterion is checked.</span>
<span class="sd">        :param int depth: Depth of recurence.</span>
<span class="sd">        :return: True if input coordinates are linear and False otherwise. Criterion is checked for coordinates in normal and reverse order.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_linear_core</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="n">depth</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_linear_core</span><span class="p">(</span><span class="n">coords</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">depth</span><span class="o">=</span><span class="n">depth</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span></div></div>


<span class="c1">################################################################################</span>
<span class="c1"># Concrete classes for linearization</span>

<div class="viewcode-block" id="LinearizeRecursiveVector"><a class="viewcode-back" href="../../../aquaduct.geom.traces.html#aquaduct.geom.traces.LinearizeRecursiveVector">[docs]</a><span class="k">class</span> <span class="nc">LinearizeRecursiveVector</span><span class="p">(</span><span class="n">LinearizeRecursive</span><span class="p">,</span> <span class="n">VectorLinearize</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ..  _simply_smooths_details:</span>

<span class="sd">    Class provides recursive linearization of coordinates with :class:`LinearizeRecursive` algorithm and the criterion of linearity implemented by :class:`VectorLinearize`. This is default method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="LinearizeRecursiveTriangle"><a class="viewcode-back" href="../../../aquaduct.geom.traces.html#aquaduct.geom.traces.LinearizeRecursiveTriangle">[docs]</a><span class="k">class</span> <span class="nc">LinearizeRecursiveTriangle</span><span class="p">(</span><span class="n">LinearizeRecursive</span><span class="p">,</span> <span class="n">TriangleLinearize</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class provides recursive linearization of coordinates with :class:`LinearizeRecursive` algorithm and the criterion of linearity implemented by :class:`TriangleLinearize`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="LinearizeHobbitVector"><a class="viewcode-back" href="../../../aquaduct.geom.traces.html#aquaduct.geom.traces.LinearizeHobbitVector">[docs]</a><span class="k">class</span> <span class="nc">LinearizeHobbitVector</span><span class="p">(</span><span class="n">LinearizeHobbit</span><span class="p">,</span> <span class="n">VectorLinearize</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class provides recursive linearization of coordinates with :class:`LinearizeHobbit` algorithm and the criterion of linearity implemented by :class:`VectorLinearize`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="LinearizeHobbitTriangle"><a class="viewcode-back" href="../../../aquaduct.geom.traces.html#aquaduct.geom.traces.LinearizeHobbitTriangle">[docs]</a><span class="k">class</span> <span class="nc">LinearizeHobbitTriangle</span><span class="p">(</span><span class="n">LinearizeHobbit</span><span class="p">,</span> <span class="n">TriangleLinearize</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class provides recursive linearization of coordinates with :class:`LinearizeHobbit` algorithm and the criterion of linearity implemented by :class:`TriangleLinearize`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="LinearizeOneWayVector"><a class="viewcode-back" href="../../../aquaduct.geom.traces.html#aquaduct.geom.traces.LinearizeOneWayVector">[docs]</a><span class="k">class</span> <span class="nc">LinearizeOneWayVector</span><span class="p">(</span><span class="n">LinearizeOneWay</span><span class="p">,</span> <span class="n">VectorLinearize</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class provides recursive linearization of coordinates with :class:`LinearizeOneWay` algorithm and the criterion of linearity implemented by :class:`VectorLinearize`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="LinearizeOneWayTriangle"><a class="viewcode-back" href="../../../aquaduct.geom.traces.html#aquaduct.geom.traces.LinearizeOneWayTriangle">[docs]</a><span class="k">class</span> <span class="nc">LinearizeOneWayTriangle</span><span class="p">(</span><span class="n">LinearizeOneWay</span><span class="p">,</span> <span class="n">TriangleLinearize</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class provides recursive linearization of coordinates with :class:`LinearizeOneWay` algorithm and the criterion of linearity implemented by :class:`TriangleLinearize`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>

<span class="c1">################################################################################</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Aqua-Duct 0.2.26 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../aquaduct.html" >aquaduct</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, 2017, Tomasz Magdziarz.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.1.
    </div>
  </body>
</html>