# -*- coding: utf8 -*-

import ConfigParser
import argparse
import sys
from collections import defaultdict
from time import time

import numpy as np

from aquaduct.traj.sandwich import Reader, Window, AtomSelection
from aquaduct.utils.multip import optimal_threads


class ReadMOL2(object):
    def __init__(self, mol2file):
        """
        Read mol2 files.

        Functionality is limited to fetching coordinates of atoms.
        Works only with files generated by WriteMOL2 class.

        :param mol2file: Filename.
        """
        self.file = open(mol2file, "r")

    def parse(self):
        """
        Parse file.

        :return: Coordinates of atoms.
        """
        lines = [line.strip() for line in self.file.readlines()]
        header_index = lines.index("@<TRIPOS>ATOM")

        coords = []
        for data in lines[header_index + 1:]:
            if data == "@<TRIPOS>BOND":
                break

            x, y, z = data.split()[2:5]
            coords.append([x, y, z])

        return np.asarray(coords, dtype=np.float32)

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.__del__()

    def __del__(self):
        self.file.close()

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("config_file", help="Config filename.")
    parser.add_argument("hotspots_file", help="Hotspots filename.")
    parser.add_argument("-d", dest="distance", required=True, help="Distance from hotspots.")
    parser.add_argument("-t", dest="threads", required=False, default=None, help="Number of threads.")
    parser.add_argument("-m", dest="max", required=False, default=None,
                        help="Maximum number of returned AA per hotspot.")
    parser.add_argument("-s", dest="minf", required=False, default=None,
                        help="Start frame.")
    parser.add_argument("-e", dest="maxf", required=False, default=None,
                        help="End frame.")

    args = parser.parse_args()

    config = ConfigParser.RawConfigParser()
    config.readfp(open(args.config_file, "r"))

    top_file = config.get("global", "top")
    trj_files = config.get("global", "trj")

    with ReadMOL2(args.hotspots_file) as hotspots_file:
        hotspots_coords = hotspots_file.parse()

    distance = args.distance

    if args.threads is None:
        optimal_threads.threads_count = optimal_threads.cpu_count + 1
    else:
        optimal_threads.threads_count = int(args.threads)

    print "Threads used: {}".format(optimal_threads.threads_count)

    Reader(top_file, trj_files, window=Window(args.minf, args.maxf, 1), threads=optimal_threads.threads_count)

    print "Frame range: {}-{}".format(Reader.window.start, Reader.window.stop)

    residue_occurences = defaultdict(dict)

    stime = time()

    print "\nFinding the hottest place in the universe:"
    for traj_reader in Reader.iterate():
        traj_reader = traj_reader.open()

        protein_atoms = traj_reader.parse_selection("protein")

        for frame in traj_reader.iterate():
            sys.stdout.write("\r {}".format(time() - stime))
            in_area = defaultdict(dict)
            for number, ids in protein_atoms.selected.iteritems():
                number_reader = protein_atoms.get_reader(number)
                for id_, coord in enumerate(number_reader.atoms_positions(ids)):
                    for hotspot_id, hotspot_coord in enumerate(hotspots_coords):

                        if float(np.linalg.norm(coord - hotspot_coord)) < float(distance):
                            if number not in in_area[hotspot_id]:
                                in_area[hotspot_id][number] = list()

                            in_area[hotspot_id][number].append(id_)

            in_area_selections = {}
            for hotspot_id, selection in in_area.iteritems():
                in_area_selections[hotspot_id] = AtomSelection(selection)

            for hotspot_id, hotspot_atom_selection in in_area_selections.iteritems():
                for id_, name in zip(hotspot_atom_selection.residues().ids(),
                                     hotspot_atom_selection.residues().names()):
                    if (id_[1], name) not in residue_occurences[hotspot_id]:
                        residue_occurences[hotspot_id][(id_[1], name)] = 0

                    residue_occurences[hotspot_id][(id_[1], name)] += 1

    print "\n"
    window_len = float(Reader.window.len())
    for hotspot_id, hotspot_occurences in residue_occurences.iteritems():
        print "-" * 20
        print hotspot_id, hotspots_coords[hotspot_id]
        print "-" * 20
        for i, res in enumerate(sorted(hotspot_occurences, key=hotspot_occurences.get, reverse=True)):
            if i == args.max:
                break

            print "{:<7} | {:5} | {:3} | {}%".format(i, res[0] + 1, res[1],
                                                     round(hotspot_occurences[res] / window_len, 2) * 100)
