# -*- coding: utf8 -*-

import ConfigParser
import argparse
from collections import defaultdict

import numpy as np
from aquaduct.traj.sandwich import Reader, Window, AtomSelection
from aquaduct.utils.multip import optimal_threads


class ReadMOL2(object):
    def __init__(self, mol2file):
        """
        Read mol2 files.

        Functionality is limited to fetching coordinates of atoms.
        Works only with files generated by WriteMOL2 class.

        :param mol2file: Filename.
        """
        self.file = open(mol2file, "r")

    def parse(self):
        """
        Parse file.

        :return: Coordinates of atoms.
        """
        lines = [line.strip() for line in self.file.readlines()]
        header_index = lines.index("@<TRIPOS>ATOM")

        coords = []
        for data in lines[header_index + 1:]:
            if data == "@<TRIPOS>BOND":
                break

            x, y, z = data.split()[2:5]
            coords.append([x, y, z])

        return np.asarray(coords, dtype=np.float32)

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.__del__()

    def __del__(self):
        self.file.close()


def remove(selection, other):
    empty_keys = []
    for number, ids in other.selected.iteritems():
        selection.selected[number] = [id_ for id_ in selection.selected[number] if id_ not in ids]

        if not selection.selected[number]:
            empty_keys.append(number)

    for k in empty_keys:
        del selection.selected[k]

    return selection


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("config_file", help="Config filename.")
    parser.add_argument("hotspots_file", help="Hotspots filename.")
    parser.add_argument("-d", dest="distance", required=True, help="Distance from hotspots.")
    parser.add_argument("-t", dest="threads", required=False, default=None, help="Number of threads.")

    args = parser.parse_args()

    config = ConfigParser.RawConfigParser()
    config.readfp(open(args.config_file, "r"))

    top_file = config.get("global", "top")
    trj_files = config.get("global", "trj")

    with ReadMOL2(args.hotspots_file) as hotspots_file:
        hotspots_coords = hotspots_file.parse()

    distance = args.distance

    if args.threads is None:
        optimal_threads.threads_count = optimal_threads.cpu_count + 1
    else:
        optimal_threads.threads_count = int(args.threads)

    Reader(top_file, trj_files, window=Window(None, 9, None), threads=optimal_threads.threads_count)

    def in_area(coord):
        for hotspot_coord in hotspots_coords:
            if np.linalg.norm(coord - hotspot_coord) <= distance:
                return True
        return False

    residues_occurences = defaultdict(int)

    for traj_reader in Reader.iterate():
        traj_reader = traj_reader.open()

        protein_atoms = traj_reader.parse_selection("protein")

        for frame in traj_reader.iterate():
            out_of_area = defaultdict(list)
            for number, ids in protein_atoms.selected.iteritems():
                number_reader = protein_atoms.get_reader(number)
                for id_, coord in enumerate(number_reader.atoms_positions(ids)):
                    if not in_area(coord):
                        out_of_area[number].append(id_)

            in_area_selection = remove(protein_atoms, AtomSelection(out_of_area))

            for id_, name in zip(in_area_selection.residues().ids(), in_area_selection.residues().names()):
                residues_occurences[(id_, name)] += 1

    window_len = float(Reader.window.len())
    for i, res in enumerate(sorted(residues_occurences, key=residues_occurences.get, reverse=True)):
        print "{:<7} | {:10} | {:3} | {}".format(i, res[0], res[1], residues_occurences[res] / window_len)