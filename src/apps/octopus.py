# -*- coding: utf8 -*-

import base64
import csv
import re
from cStringIO import StringIO
from collections import defaultdict

import matplotlib.pyplot as plt
import numpy as np
from aquaduct.traj.sandwich import Reader, Window

colors = ["#e6194b", "#3cb44b", "#ffe119", "#4363d8", "#f58231", "#911eb4", "#46f0f0",
          "#f032e6", "#bcf60c", "#fabebe", "#008080", "#e6beff", "#9a6324",
          "#800000", "#aaffc3", "#808000", "#ffd8b1", "#000075", "#808080"]


def is_float(value):
    try:
        float(value)
        return True
    except:
        return False


class FileDataProcessor(object):
    def __init__(self, filename):
        self.file = open(filename, "r")
        self.file_lines = [line.strip() for line in self.file.readlines()]

        # TODO: There can be more data for each traced molecule
        self.allowed_table_names = ["Clusters summary - inlets",
                                    "Clusters summary - areas",
                                    "List of separate paths and properties"]

        self.table_end_pattern = "-+"

        self.data = {}
        self._find_tables()

    def get_column_values(self, table_name, column_name):
        return [row[column_name] for row in self.data[table_name]]

    def get_column_names(self, table_name):
        return list(self.data[table_name][0].iterkeys())

    def _find_tables(self):
        for i, line in enumerate(self.file_lines):
            if line.strip() in self.allowed_table_names:
                self._parse_columns(i)

    def _parse_columns(self, start_line):
        table_name = self.file_lines[start_line]
        self.data[table_name] = []

        column_names = self.file_lines[start_line + 2].split()

        for line in self.file_lines[start_line + 4:]:
            if re.match(self.table_end_pattern, line):
                break

            values = []
            for value in line.split():
                if value.isdigit():
                    value = int(value)
                elif is_float(value):
                    value = float(value)

                values.append(value)

            dict_values = {}
            for i in range(0, len(values)):
                dict_values.update({column_names[i]: values[i]})

            self.data[table_name].append(dict_values)

    def __del__(self):
        self.file.close()


class CSVDataProcessor(object):
    def __init__(self, filename):
        self.file = open(filename, "r")
        self.csv_reader = csv.DictReader(self.file)

        self.column_names = list(self.csv_reader.next().iterkeys())
        self.seek_file()

    def get_column_values(self, column_name):
        values = [int(row[column_name]) for row in self.csv_reader]
        self.seek_file()

        return values

    def seek_file(self):
        """ Set file position at beginning and skip first row with column names """
        self.file.seek(0)
        self.csv_reader.next()

    def __del__(self):
        self.file.close()


class ReadMOL2(object):
    def __init__(self, mol2file):
        """
        Read mol2 files.

        Functionality is limited to fetching coordinates of atoms.
        Works only with files generated by WriteMOL2 class.

        :param mol2file: Filename.
        """
        self.file = open(mol2file, "r")

    def parse(self):
        """
        Parse file.

        :return: Coordinates of atoms.
        """
        lines = [line.strip() for line in self.file.readlines()]
        header_index = lines.index("@<TRIPOS>ATOM")

        coords = []
        for data in lines[header_index + 1:]:
            if data == "@<TRIPOS>BOND":
                break

            x, y, z = data.split()[2:5]
            coords.append([x, y, z])

        return np.asarray(coords, dtype=np.float32)

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.__del__()

    def __del__(self):
        self.file.close()


class HTML_IMG(object):
    def __init__(self, img_data):
        self.img_data = img_data

    @property
    def html_code(self):
        return "<img src=\"data:image/png;base64,{}\">".format(self.img_data)


class HTML_TABLE(object):
    def __init__(self, labels, columns):
        self.labels = labels
        self.columns = columns

    @property
    def html_code(self):
        # TODO: Return html table
        pass


# 1
def cluster_inlets(file_processor):
    fig, ax = plt.subplots()

    cluster_no = file_processor.get_column_values("Clusters summary - inlets", "Cluster")

    y_in = file_processor.get_column_values("Clusters summary - inlets", "INCOMING")
    y_out = file_processor.get_column_values("Clusters summary - inlets", "OUTGOING")

    # Added 1 to make place for previous bar
    rects_bottom = ax.bar(range(1, len(cluster_no) + 1), y_in, label="INCOMING")
    rects_top = ax.bar(range(1, len(cluster_no) + 1), y_out, bottom=y_in, label="OUTGOING")

    for rect_b, rect_t in zip(rects_bottom, rects_top):
        width_b = rect_b.get_width()
        height_b = rect_b.get_height()
        if height_b >= 50:
            ax.text(rect_b.get_x() + width_b / 2, height_b - 50, height_b,
                    fontsize=7,
                    color=(1, 1, 1),
                    horizontalalignment="center",
                    verticalalignment="center")

        width_t = rect_t.get_width()
        height_t = rect_t.get_height()
        if height_t >= 50:
            ax.text(rect_t.get_x() + width_t / 2, height_b + height_t - 50, height_t,
                    fontsize=7,
                    color=(1, 1, 1),
                    horizontalalignment="center",
                    verticalalignment="center")

    ax.set_title("Clusters inlets")
    ax.set_xlabel("Cluster")
    ax.set_ylabel("Size")

    ax.set_xlim((0, len(cluster_no) + 1))
    ax.set_xticks(range(1, len(cluster_no) + 1))
    ax.set_xticklabels(cluster_no)

    ax.legend(bbox_to_anchor=(1.02, 1), loc="upper left")

    return fig


# 2
def relative_clusters_flows(csv_processor, clusters_names, labels, colors):
    fig, ax = plt.subplots()

    x = csv_processor.get_column_values("# frame")

    all_paths_per_frame = csv_processor.get_column_values("amol_apaths_aclusts_walk")

    for cluster_name, label, color in zip(clusters_names, labels, colors):
        cluster_paths_per_frame = csv_processor.get_column_values(cluster_name)

        y = [float(cluster_paths) / all_paths if all_paths else 0
             for cluster_paths, all_paths in zip(cluster_paths_per_frame, all_paths_per_frame)]

        ax.plot(x, y, label=label, color=color)

    ax.set_title("Relative cluster flows")
    ax.set_xlabel("Frame")
    ax.set_ylabel("???")
    ax.legend(bbox_to_anchor=(1.02, 1), loc="upper left")

    ax.xaxis.set_major_locator(plt.AutoLocator())
    ax.set_xlim((0, len(x)))
    ax.set_ylim((0, 1.05))  # added 0.05 because when there is 1, its not visible

    return fig


# 3
def ligands_time(file_processor):
    fig, ax = plt.subplots()

    plot_settings = dict(align="edge", height=1.0)

    ax.set_title("Ligands in time")
    ax.set_xlabel("Frame")
    ax.set_ylabel("Separate path ID")

    path_nr = file_processor.get_column_values("List of separate paths and properties", "Nr")
    path_nr = [y - 1 for y in path_nr]

    beg_values = file_processor.get_column_values("List of separate paths and properties", "BeginF")
    inp_values = file_processor.get_column_values("List of separate paths and properties", "InpF")
    obj_values = file_processor.get_column_values("List of separate paths and properties", "ObjF")
    out_values = file_processor.get_column_values("List of separate paths and properties", "OutF")

    # Sort all basing on BeginF
    beg_values, inp_values, obj_values, out_values = zip(*sorted(zip(beg_values,
                                                                     inp_values,
                                                                     obj_values,
                                                                     out_values)))

    max_x = max(file_processor.get_column_values("List of separate paths and properties", "EndF"))

    # ax.set_xlim((0, max_x))
    ax.set_ylim((0, max(path_nr)))

    inps_left = beg_values
    inps_width = [width if width - 1 >= 0 else 0 for width in inp_values]

    objs_left = [sum(values) for values in zip(beg_values, inp_values)]
    objs_width = [width - 1 for width in obj_values]

    outs_left = [sum(values) for values in zip(beg_values, inp_values, obj_values)]
    outs_width = [width - 1 for width in out_values]

    ax.barh(path_nr, inps_width, left=inps_left, color=(1, 0, 0), label="Incoming", **plot_settings)
    ax.barh(path_nr, objs_width, left=objs_left, color=(0, 1, 0), label="Object", **plot_settings)
    ax.barh(path_nr, outs_width, left=outs_left, color=(0, 0, 1), label="Outgoing", **plot_settings)

    ax.legend(bbox_to_anchor=(1.02, 1), loc="upper left")

    return fig


# 6
def hotspots_aa_list(top_file, trj_files):
    # Reader.reset()
    Reader(top_file, trj_files, window=Window(None, 10, None))  # TODO: sandwich z configu

    with ReadMOL2("hotspots1.mol2") as hotspots_file:
        hotspots_coords = hotspots_file.parse()

    distance = 3

    def in_dist(res_data):
        _, coords = res_data
        for hotspot_coord in hotspots_coords:
            if np.linalg.norm(coords - hotspot_coord) <= distance:
                return True

    def ids_to_name(ids):
        ids_index = list(protein_residues.ids()).index(ids)
        return list(protein_residues.names())[ids_index]

    residues = defaultdict(int)

    for traj_reader in Reader.iterate():
        traj_reader = traj_reader.open()
        protein_residues = traj_reader.parse_selection("protein").residues()
        protein_residues.uniquify()

        residues_ids = list(protein_residues.ids())
        residues_names = list(protein_residues.names())
        residues_coords = protein_residues.coords()

        # Iterate through frames
        for frame in Reader.window.range():
            traj_reader.set_frame(frame)

            res_in_dist = np.asarray(filter(in_dist, zip(residues_ids,
                                                         residues_coords)))
            for res_id, _ in res_in_dist:
                residues[res_id] += 1

        window_len = float(Reader.window.len())
        print
        for ids, occurences in residues.iteritems():
            name = residues_names[residues_ids.index(ids)]
            print "{:10} | {:3} | {}".format(ids, name, occurences / window_len)


# 8
def cluster_area(file_processor):
    fig, ax = plt.subplots()

    ax.set_title("Cluster areas")
    ax.set_xlabel("Density")
    ax.set_ylabel("???")

    column_names = file_processor.get_column_names("Clusters summary - areas")

    x = [name for name in column_names if name.startswith("D")]
    x.sort(key=lambda x: int(x[1:]), reverse=True)

    y = [file_processor.get_column_values("Clusters summary - areas", density)[0] for density in x]

    ax.set_xlim((0, len(x) - 1))  # Fix problem with offset form y axe
    ax.plot(x, y)

    return fig


def main():
    c = CSVDataProcessor("5_analysis_results.txt.csv")
    f = FileDataProcessor("5_analysis_results.txt")

    l = []

    ci = StringIO()
    cluster_inlets(f).savefig(ci, format="png", bbox_inches="tight")
    l.append(ci)

    rcf = StringIO()
    # Finding all clusters
    clusters = []
    labels = []
    for column_name in c.column_names:
        match = re.match("amol_apaths_(\d+)_walk$", column_name)
        if match:
            clusters.append(match.group(0))
            labels.append(int(match.group(1)))

    labels, clusters = zip(*sorted(zip(labels, clusters)))
    labels = ["Cluster " + str(i) for i in labels]

    relative_clusters_flows(c, clusters, labels, colors).savefig(rcf, format="png", bbox_inches="tight")
    l.append(rcf)

    lt = StringIO()
    ligands_time(f).savefig(lt, format="png", bbox_inches="tight")
    l.append(lt)

    ca = StringIO()
    cluster_area(f).savefig(ca, format="png")
    l.append(ca)

    html = ""
    for i, f in enumerate(l):
        html += """
    <div style="text-align: center">
        <h1>#{}</h1>
        <img src=\"data:image/png;base64,{}\">
        <hr />
    </div>
            """.format(i, base64.encodestring(f.getvalue()))

    with open("graphs.html", "w+") as f:
        f.write(html)


if __name__ == "__main__":
    # main()
    hotspots_aa_list("1cqz_topology.pdb",
                     "1cqz_10ns_trajectory.nc")
